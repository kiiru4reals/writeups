### Introduction
A Certificate authority is an entity that has been granted the mandate to generate and issue SSL certificates to users. An SSL certificate is a certificate that is used to legitimize a website's identity and plays a part in enabling an encrypted connection. The SSL certificate is what is used to show that a site securely transfers information to the application server. This is often represented by a padlock on the browser like the one shown below
![[Pasted image 20241207035804.png]]
Globally there are more than 100 Certificate Authorities (CAs) who are responsible for providing SSL certificates to all websites that have an SSL certificate. The reason that these CAs are relatively few is because these entities have been trusted by the various organizations to provide a secure connection to end-users. 
### So how do these CAs work?
When a website administrator purchases a SSL certificate, they get two files (or three?) a key and a certificate. The purpose of this key is to encrypt and decrypt the information being transferred by the server. The purpose of the certificate is to verify the identity of a website.
Certificates issues to you as a consumer is what is referred to as an **End-entity certificate**. This certificate is generated by a certificate known as an **intermediate certificate**. The role of the intermediate certificate is to sign the end-entity certificate and to act as a link between the **root certificate** and the end-entity certificate. The root certificate is the mother of all certificates. The root certificate is stored on the browser and is responsible for signing the intermediate certificate directly which creates a chain of trust.
When you open your favorite website, a check to verify the certificate is done by the intermediate certificate which then compares the signature with the root certificate.
### What is the underlying infrastructure of a CA?
Well this is the most complicated bit of this article. **sips water**
There are many parties involved in the lifecycle of a SSL certificate. These parties are collectively reffered to as the Public Key Infrastructure (PKI), for a web administrator to be able to get a SSL certificate, they make a request to what is called a **Registration Authority (RA)** who then performs some sort of a KYC to verify that the user sctually owns the domain that they are requesting the SSL for and issues the End-entity certificate. The certificate authority has a root CA which then partners with software providers to embed the root certificate to the browser.  
Certificates are not meant to last forever, just like life, when the certificate lifespan comes to an end, it is added on a list known as the Certificate Revocation List (CRL). The CRL is stored on a service which is used by the CA to check if the certificate has expired, this service is known as the CRL distribution point. It is important to note that the serial number is what is added to the CRL.
### The meat
Now that we have the theory bit done, we can proceed to the practical aspect of it. To demonstrate this, we can use Hashicorp Vault which we shall use to set up our Certificate Authority.
Certificate Authority is best used in internal networks where the organization intends to have a lot of applications that run internally and data being transmitted to and from the server needs to be encrypted in transit. It is not recommended to have these certificates running on a service that is exposed on the internet, this is because that this certificate is not trusted on the client's side as shown below

![[Pasted image 20241207045949.png]]
I shall also be using Terraform to set this up on Vault because why not?
#### Generation of the root CA
The first step we need to do is to set up the root CA on Vault, before that we need to enable our PKI secret engine and set our certificate's time to live.

```hcl
# Enable the PKI secrets engine

resource "vault_mount" "pki" {
	path = "pki"
	type = "pki"
	description = "This is PKI."
	default_lease_ttl_seconds = 2592000
	max_lease_ttl_seconds = 2592000
}
```

The next step will be to create the root certificate
```hcl
resource "vault_pki_secret_backend_root_cert" "root_ca" {
	backend = vault_mount.pki.path
	type = "internal"
	common_name = "kiirumaina.com"
	ttl = 2592000
	issuer_name = "kiiru_maina"
}
```

We then proceed to create a root issuer who shall act as the creator of the root CA
```hcl
resource "vault_pki_secret_backend_issuer" "root_ca" {
	backend = vault_mount.pki.path
	issuer_ref = vault_pki_secret_backend_root_cert.root_ca.issuer_id
	issuer_name = vault_pki_secret_backend_root_cert.root_ca.issuer_name
	revocation_signature_algorithm = "SHA256WithRSA"
```
To avoid interacting with our root CA and for an easier rotation process (yes, certificates are also secrets that need to be rotated every once in a while), we can create a role and link it to the root CA and limit it to our domain.
```hcl
resource "vault_pki_secret_backend_role" "root_ca_role" {
	backend = vault_mount.pki.path
	name = "root_ca_role"
	ttl = 2592000
	allow_ip_sans = true
	key_type = "rsa"
	key_bits = 4096
	allow_subdomains = true
	allowed_domains = ["kiirumaina.com"]
	allow_any_name = true
}
```
We then proceed our CA and CRL URL that will be used to communicate with the root CA and the CRL.
```hcl
resource "vault_pki_secret_backend_config_urls" "crl_urls" {
	backend = vault_mount.pki.path
	issuing_certificates = ["https://${var.vault_subdomain}:8200/v1/pki/ca"] # CA URL
	crl_distribution_points = ["https://${var.vault_subdomain}:8200/v1.pki/crl"] # CRL URL
}
```
#### Generation of the intermediate certificate
We start by initializing another path for PKI as we did with the root CA but we call this path `pki_int`
```hcl
resource "vault_mount" "pki_int" {
	path = "pki_int"
	type = "pki"
	description = "Intermediate CA"
	default_lease_ttl_seconds = 1296000
	max_lease_ttl_seconds = 1296000
}
```
We then proceed to create a Certificate Signing Request from the root CA, as we had discussed in the beginning the intermediate CA is signed by the root CA for it to generate end-entity certificate. 
```hcl
resource "vault_pki_secret_backend_intermediate_cert_request" "csr-request" {
	backend = vault_mount.pki.path
	type = "internal"
	common_name = "kiirumaina.com intermediate authority"
}
```
We then proceed to sign our intermediate certificate with the root certificate as shown below
```hcl
resource "vault_pki_secret_backend_root_sign_intermediate" "sign_intermediate_certificate" {
	backend = vault_mount.pki.path
	common_name = "kiiru_maina_intermediate_new"
	csr = vault_pki_secret_backend_intermediate_cert_request.csr-request.csr
	format = "pem_bundle"
	ttl = 648000
	issuer_ref = vault_pki_secret_backend_root_cert.root_ca.issuer_id
}
```
It is important to note that the signed certificate was not imported to Vault, we can then push the certificate to Vault.
```hcl
resource "vault_pki_secret_backend_intermediate_set_signed" "imported_certificate" {
	backend = vault_mount.pki_int.path
	certificate = vault_pki_secret_backend_root_sign_intermediate.sign_intermediate_certificate.certificate
}
```
We can then proceed to create a role that our intermediate CA will use to interact with the root CA. To learn more about what a role is kindly visit this link Roles in [Hashicorp Vault](https://developer.hashicorp.com/vault/tutorials/get-started/introduction-roles). 
```hcl
resource "vault_pki_secret_backend_role" "intermediate_role" {
backend = vault_mount.pki_int.path
issuer_ref = vault_pki_secret_backend_issuer.root_ca.issuer_ref
name = "kiiru-maina-dot-com"
ttl = 1296000
max_ttl = 2592000
allow_ip_sans = true
key_type = "rsa"
key_bits = 4096
allowed_domains = ["kiirumaina.com"]
allow_subdomains = true
}
```
We can then look at the role we have created using the following API request to our vault server
```sh
curl --header "X-Vault-Token: <Your Vault token>" \
    --request POST \
    --data '{"common_name": "test.kiirumaina.com", "ttl": "24h"}' \
    https://vault.kiirumaina.com:8200/v1/pki_int/issue/kiirumaina-dot-com | jq 

```

The response was able to give us a copy of a certificate that is valid for 24 hours that we can use on our server as shown below:
![[Pasted image 20241214174817.png]]

Should you need to revoke the certificate, we can use the revoke endpoint on Vault as shown below:
```sh
curl --header "X-Vault-Token: <Your Vault token>" \
    --request POST \
    --data '{"serial_number": "1b:c2:58:5c:ec:14:c1:e8:58:05:95:9c:95:b7:43:24:f6:b0:3e:77"}' \
    https://vault.kiirumaina.com:8200/v1/pki_int/revoke | jq
```
We get the following certificate which then added to our CRL that we created earlier

![[Pasted image 20241214175306.png]]
### Conclusion
Setting up a Certificate Authority (CA) using Hashicorp Vault gives your organization the ability to manage their internal certificate life cycle securely and efficiently. Other things that an organization can look into is seamlessly rotating these certificates to ensure that these secrets are often rotated and are short lived to ensure that the key management practices of an organization is healthy.